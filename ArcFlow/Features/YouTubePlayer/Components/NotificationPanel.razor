
@using ArcFlow.Features.YouTubePlayer.State
@implements IDisposable

<div class="notification-container">
    @foreach (var notification in Notifications)
    {
        <div class="notification-item notification-@notification.Severity.ToString().ToLower()">
            <div class="notification-content">
                <div class="notification-icon">
                    @GetIcon(notification.Severity)
                </div>
                <div class="notification-message">
                    @notification.Message
                </div>
                @if (notification.IsDismissible)
                {
                    <button class="notification-close" @onclick="() => OnDismiss.InvokeAsync(notification.CorrelationId)">
                        <span>&times;</span>
                    </button>
                }
            </div>
        </div>
    }
</div>

@code {
    [Parameter, EditorRequired]
    public IReadOnlyList<Notification> Notifications { get; set; } = [];

    [Parameter]
    public EventCallback<Guid> OnDismiss { get; set; }
    
    private readonly Dictionary<Guid, CancellationTokenSource> _autoDismissTasks = new();
    
    protected override void OnParametersSet()
    {
        var currentIds = Notifications.Select(n => n.CorrelationId).ToHashSet();
        
        // Cancel tasks for removed notifications
        foreach (var (id, cts) in _autoDismissTasks.Where(kvp => !currentIds.Contains(kvp.Key)).ToList())
        {
            cts.Cancel();
            cts.Dispose();
            _autoDismissTasks.Remove(id);
        }
        
        // Start auto-dismiss for new notifications
        foreach (var notification in Notifications)
        {
            if (notification.IsDismissible && !_autoDismissTasks.ContainsKey(notification.CorrelationId))
            {
                var cts = new CancellationTokenSource();
                _autoDismissTasks[notification.CorrelationId] = cts;
                
                _ = AutoDismissAsync(notification.CorrelationId, cts.Token);
            }
        }
    }

    private async Task AutoDismissAsync(Guid correlationId, CancellationToken cancellationToken)
    {
        try
        {
            await Task.Delay(5000, cancellationToken);
            
            if (!cancellationToken.IsCancellationRequested)
            {
                await InvokeAsync(() => OnDismiss.InvokeAsync(correlationId));
            }
        }
        catch (TaskCanceledException)
        {
            // Expected when notification is manually dismissed
        }
        finally
        {
            if (_autoDismissTasks.TryGetValue(correlationId, out var cts))
            {
                cts.Dispose();
                _autoDismissTasks.Remove(correlationId);
            }
        }
    }

    private string GetIcon(NotificationSeverity severity) => severity switch
    {
        NotificationSeverity.Success => "✓",
        NotificationSeverity.Info => "ℹ",
        NotificationSeverity.Warning => "⚠",
        NotificationSeverity.Error => "✕",
        _ => "•"
    };
    
    public void Dispose()
    {
        foreach (var cts in _autoDismissTasks.Values)
        {
            cts.Cancel();
            cts.Dispose();
        }
        _autoDismissTasks.Clear();
    }
}